<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Chao&#39;s blog and project</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Chao&#39;s blog and project">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Chao&#39;s blog and project">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ho Ngok Chao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Chao's blog and project" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chao&#39;s blog and project</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-backtracking" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/13/backtracking/" class="article-date">
  <time class="dt-published" datetime="2022-04-13T15:41:08.469Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/13/backtracking/">Review of Back tracking (one kind of DFS) framework</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This is a review of <a target="_blank" rel="noopener" href="https://labuladong.github.io/algo/1/5/">回溯算法解題套路框架</a><br>Framework:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if path meets requirement:</span><br><span class="line">    result.add(path.copy())</span><br><span class="line">for option in available options:</span><br><span class="line">    path.add(option) # make a decision</span><br><span class="line">    backtrack(path,available options)</span><br><span class="line">    path.remove(option) # cancle a decision</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">Leet coce 46. Permutations</a><br>Using the general framework, it is perhap easier to find this solution first, which used addtional time complexity to find if the options is used.</p>
<p>time complexity: O( n!^2 )<br>space complexity: O( (n!+1)*n )</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        self.result=[]</span><br><span class="line">        self.recursive([],nums)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">self,track,nums</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums):</span><br><span class="line">            self.result.append(track.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> element <span class="keyword">in</span> track:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            track.append(element)</span><br><span class="line">            self.recursive(track,nums)</span><br><span class="line">            track.pop()</span><br></pre></td></tr></table></figure>

<p>but through swapping we don’t need to use extra time to check if elements have been used before; elements in current (start,end) range hasn’t been used before.<br>time complexity: O(n!)<br>space complexity: O( (n!+1)*n )</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        self.result=[]</span><br><span class="line">        self.recursive(<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>,nums)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">self,start,end,nums</span>):</span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            self.result.append(nums.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,end+<span class="number">1</span>):</span><br><span class="line">            temp = nums[start]</span><br><span class="line">            nums[start] = nums[i]</span><br><span class="line">            nums[i] = temp</span><br><span class="line">            self.recursive(start+<span class="number">1</span>,end,nums)</span><br><span class="line">            temp = nums[i]</span><br><span class="line">            nums[i] = nums[start]</span><br><span class="line">            nums[start] = temp</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-queens/">Leetcode 51. N-Queens</a></p>
<p>Time complexity: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/21059422/time-complexity-of-n-queen-using-backtracking">O(n!)</a> since T(n) &#x3D; n * T(n-1) + O(n^2) expand to T(n) &#x3D; O(n!) + O(n^3) &#x3D; O(n!)</p>
<p>Space complexity: O(n^4)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        self.board = [[<span class="string">&#x27;.&#x27;</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        self.result = []</span><br><span class="line">        self.n = n </span><br><span class="line">        self.backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">self, i, j</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="comment"># check same column</span></span><br><span class="line">            <span class="keyword">if</span> self.board[x][j] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> j-(i-x) &gt;= <span class="number">0</span> <span class="keyword">and</span> self.board[x][j-(i-x)] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> j+(i-x) &lt; self.n <span class="keyword">and</span> self.board[x][j+(i-x)] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self,i</span>):</span><br><span class="line">        <span class="keyword">if</span> i == self.n:</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">                temp.append(<span class="string">&quot;&quot;</span>.join(self.board[x]))</span><br><span class="line">            self.result.append(temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.is_valid(i,j):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.board[i][j] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            self.backtrack(i+<span class="number">1</span>)</span><br><span class="line">            self.board[i][j] = <span class="string">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/13/backtracking/" data-id="cl1xqpli60000afno9zigc3z5" data-title="Review of Back tracking (one kind of DFS) framework" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DFS-backtrack-python/" rel="tag">DFS, backtrack, python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-binarytree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/13/binarytree/" class="article-date">
  <time class="dt-published" datetime="2022-04-13T15:41:08.469Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This a review of <a target="_blank" rel="noopener" href="https://labuladong.github.io/algo/1/7/">東哥帶你刷二叉樹</a></p>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p>You can solve problem with binary tree with two methods:</p>
<ul>
<li>backtracking</li>
<li>dynamic programming</li>
</ul>
<p>Using the <a target="_blank" rel="noopener" href="https://hackmd.io/3HEM3FA1RiKcWVJhSkC6ww">framework of backtracking</a> we make decision preorder and cancel decision postorder:<br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">Leet code 104. Maximum Depth of Binary Tree</a><br>Time complexity: O(N) traverse through all nodes<br>Space complexity: O(N) worst case the callback stack depth would be N</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.depth = <span class="number">0</span></span><br><span class="line">        self.result = <span class="number">0</span></span><br><span class="line">        self.traverse(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.depth&gt;self.result:</span><br><span class="line">                self.result = self.depth</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.depth += <span class="number">1</span> <span class="comment"># preorder position</span></span><br><span class="line">        self.traverse(node.left)</span><br><span class="line">        self.traverse(node.right)</span><br><span class="line">        self.depth -= <span class="number">1</span> <span class="comment"># postorder position</span></span><br></pre></td></tr></table></figure>
<p>Using the <a target="_blank" rel="noopener" href="https://hackmd.io/6MGw9QgbTe-z_5tI3kSwfg">framework of dynamic programming</a>, we define subproblem and obtain optimal solution for each subproblem via state transition function <code>max(left_max,right_max)+1</code></p>
<p>Time complexity: O(N) traverse through all nodes<br>Space complexity: O(N) worst case the callback stack depth would be N</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_max = self.maxDepth(root.left)</span><br><span class="line">        right_max = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_max,right_max)+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/diameter-of-binary-tree/">leetcode 543. Diameter of Binary Tree</a><br>Time complexity: O(N) traverse through all nodes<br>Space complexity: O(N) worst case the callback stack depth would be N</p>
<p>Which is just an extension of above, if you discover that the subproblem’s solution equal to <code>current_max_diameter = max_left_depth + max_right_depth</code> and in postorder we already have <code>max_left_depth</code> and <code>max_right_depth</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.max_diameter = <span class="number">0</span></span><br><span class="line">        self.max_depth(root)</span><br><span class="line">        <span class="keyword">return</span> self.max_diameter</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">max_depth</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        right_depth = self.max_depth(root.right)</span><br><span class="line">        left_depth = self.max_depth(root.left)</span><br><span class="line">        </span><br><span class="line">        my_diameter = left_depth + right_depth</span><br><span class="line">        <span class="keyword">if</span> self.max_diameter &lt; my_diameter:</span><br><span class="line">            self.max_diameter = my_diameter </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(right_depth,left_depth)+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/">144. Binary Tree Preorder Traversal</a><br>Typical solution from definition<br>time complexity: O(N)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        self.res = []</span><br><span class="line">        self.traverse(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self,node</span>):</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            self.res.append(node.val)</span><br><span class="line">            self.traverse(node.left)</span><br><span class="line">            self.traverse(node.right)</span><br></pre></td></tr></table></figure>
<p>Using the recursive kind of thinking, we can also divide the preorder traversal problem to subproblems of its sub-trees:</p>
<p>But the time complexity is O(N^2) due to python’s list extend is O(N) and we do that to every node.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            res.extend(self.preorderTraversal(root.left))</span><br><span class="line">            res.extend(self.preorderTraversal(root.right))</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/13/binarytree/" data-id="cl1xqplib0001afno9p9fbzmp" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-coroutine" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/13/coroutine/" class="article-date">
  <time class="dt-published" datetime="2022-04-13T15:41:08.469Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/13/coroutine/">Review of How the heck does async/await work in Python 3.5?</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This is a review of <a target="_blank" rel="noopener" href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/">How the heck does async&#x2F;await work in Python 3.5?</a></p>
<h2 id="Generator-and-Coroutines"><a href="#Generator-and-Coroutines" class="headerlink" title="Generator and Coroutines"></a>Generator and Coroutines</h2><p>My understanding of Generator before reading the article has been something like this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lazy_range</span>(<span class="params">up_to</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generator to return the sequence of integers from 0 to up_to, exclusive.&quot;&quot;&quot;</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; up_to:</span><br><span class="line">        <span class="keyword">yield</span> index</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lazy_range(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>from <a target="_blank" rel="noopener" href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/">https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/</a></p>
</blockquote>
<p>It saves memory so that each time it only generates one number and suspend there to come back until for loop call <code>__next__()</code> and eventually throw StopIteration which for loop would capture.</p>
<p>Which fits the definition from wikipedia,</p>
<blockquote>
<p>“Coroutines are computer program components that generalize subroutines for nonpreemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations”</p>
</blockquote>
<p>or in python documentation,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Coroutines are a more generalized form of subroutines. Subroutines are entered at one point and exited at another point. Coroutines can be entered, exited, and resumed at many different points. They can be implemented with the async def statement. See also PEP 492.</span><br></pre></td></tr></table></figure>

<p>But since PEP342, we have send() method so we can send values to where the generators paused;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">jumping_range</span>(<span class="params">up_to</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generator for the sequence of integers from 0 to up_to, exclusive.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Sending a value into the generator will shift the sequence by that amount.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; up_to:</span><br><span class="line">        jump = <span class="keyword">yield</span> index</span><br><span class="line">        <span class="keyword">if</span> jump <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            jump = <span class="number">1</span></span><br><span class="line">        index += jump</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    iterator = jumping_range(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(iterator))  <span class="comment"># 0</span></span><br><span class="line">    <span class="built_in">print</span>(iterator.send(<span class="number">2</span>))  <span class="comment"># 2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(iterator))  <span class="comment"># 3</span></span><br><span class="line">    <span class="built_in">print</span>(iterator.send(-<span class="number">1</span>))  <span class="comment"># 2</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterator:</span><br><span class="line">        <span class="built_in">print</span>(x)  <span class="comment"># 3, 4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>take from <a target="_blank" rel="noopener" href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/">https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/</a></p>
</blockquote>
<h2 id="yield-from-example"><a href="#yield-from-example" class="headerlink" title="yield from example"></a>yield from example</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bottom</span>():</span><br><span class="line">    <span class="comment"># Returning the yield lets the value that goes up the call stack to come right back</span></span><br><span class="line">    <span class="comment"># down.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">middle</span>():</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="keyword">from</span> bottom())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">top</span>():</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="keyword">from</span> middle())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the generator.</span></span><br><span class="line">gen = top()</span><br><span class="line">value = <span class="built_in">next</span>(gen)</span><br><span class="line"><span class="built_in">print</span>(value)  <span class="comment"># Prints &#x27;42&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if we call below, bottom() would call return which raised StopIteration since it is a generator</span></span><br><span class="line"><span class="comment"># and yield from would propagate the StopIteration back</span></span><br><span class="line"><span class="comment"># value = next(gen)</span></span><br><span class="line"><span class="comment"># print(value)  # Prints &#x27;42&#x27;.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    value = gen.send(value * <span class="number">2</span>) </span><br><span class="line">    <span class="comment"># since top paused at calling yield from middle() again</span></span><br><span class="line">    <span class="comment"># it becomes return 84 which return StopIteration object</span></span><br><span class="line">    <span class="comment">#  with attribute value = 84</span></span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line">    value = exc.value</span><br><span class="line"><span class="built_in">print</span>(value)  <span class="comment"># Prints &#x27;84&#x27;.</span></span><br></pre></td></tr></table></figure>

<h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>Going back to Wikipedia, an event loop “is a programming construct that waits for and dispatches events or messages in a program”</p>
<p>Python adopts event loop in the form of <code>asyncio</code></p>
<h2 id="asyncio-example"><a href="#asyncio-example" class="headerlink" title="asyncio example"></a>asyncio example</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3.4</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># Borrowed from http://curio.readthedocs.org/en/latest/tutorial.html.</span></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">number, n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n, <span class="string">&#x27;(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(number))</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(countdown(<span class="string">&quot;A&quot;</span>, <span class="number">2</span>)),</span><br><span class="line">    asyncio.ensure_future(countdown(<span class="string">&quot;B&quot;</span>, <span class="number">3</span>))]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>event loop here would monitor the asyncio.Future object e.g. asyncio.sleep(1)</p>
<p>In python 3.5 we can use <code>@types.coroutine</code> to label a generator as coroutine</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="comment"># Borrowed from http://curio.readthedocs.org/en/latest/tutorial.html.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@types.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">number, n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n, <span class="string">&#x27;(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(number))</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(countdown(<span class="string">&quot;A&quot;</span>, <span class="number">2</span>)),</span><br><span class="line">    asyncio.ensure_future(countdown(<span class="string">&quot;B&quot;</span>, <span class="number">3</span>))]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>or use async&#x2F;await, you need to <code>await</code> an <code>awaitable object</code> (coroutines and other objects that defines an <strong>await</strong>())</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="comment"># Borrowed from http://curio.readthedocs.org/en/latest/tutorial.html.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">number, n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n, <span class="string">&#x27;(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(number))</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(countdown(<span class="string">&quot;A&quot;</span>, <span class="number">2</span>)),</span><br><span class="line">    asyncio.ensure_future(countdown(<span class="string">&quot;B&quot;</span>, <span class="number">3</span>))]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>The latter is async-based coroutine and the former ones are generator-based courtine and only generator-based coroutines.</p>
<blockquote>
<p>One very key point I want to make about the difference between a generator-based coroutine and an async one is that only generator-based coroutines can actually pause execution and force something to be sent down to the event loop.<br><a target="_blank" rel="noopener" href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/">https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py</span></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">delay, result=<span class="literal">None</span>, *, loop=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Coroutine that completes after a given time (in seconds).&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> delay == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> loop <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        loop = events.get_event_loop()</span><br><span class="line">    future = loop.create_future()</span><br><span class="line">    h = future._loop.call_later(delay,</span><br><span class="line">                                futures._set_result_unless_cancelled,</span><br><span class="line">                                future, result)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="keyword">from</span> future)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        h.cancel()</span><br></pre></td></tr></table></figure>

<p>The author at the end use 100 lines of python to demontrate how to achieve concurrency using single thread via coroutine. I would like to break the 100 lines to smaller pieces for reading.</p>
<p>First, just like asyncio.sleep; this is a generator-based coroutine; when later being called in <code>await sleep(delay)</code>, yield wait_until will pause the generator and propagate back to <em>async def countdown</em> (below) and in turns propagate back to <em>class SleepingLoop</em> to help contruct the min heap with smallest wait time on heap top.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@types.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">seconds</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Pause a coroutine for the specified number of seconds.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Think of this as being like asyncio.sleep()/curio.sleep().</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    wait_until = now + datetime.timedelta(seconds=seconds)</span><br><span class="line">    <span class="comment"># Make all coroutines on the call stack pause; the need to use `yield`</span></span><br><span class="line">    <span class="comment"># necessitates this be generator-based and not an async-based coroutine.</span></span><br><span class="line">    actual = <span class="keyword">yield</span> wait_until</span><br><span class="line">    <span class="comment"># Resume the execution stack, sending back how long we actually waited.</span></span><br><span class="line">    <span class="keyword">return</span> actual - now</span><br></pre></td></tr></table></figure>

<p>The async coroutine task (which can’t really pause by itself, but rely on sleep to pause), after the first run triggered by <code>send(None)</code> it paused at the await before assigning delta, we enter it again when <code>task.coro.send(now)</code> is called after we sleep through the interval of the current smallest wait time in the heap, and now is propgate to sleep and become the local scope actual and finally return and assign to delta in <strong>async def countdown</strong> and we run until it enter sleep again and create another task in the SleepingLoop’s heap with new <code>wait_until</code>; similarly the next time it is entered with another <code>task.coro.send(now)</code> it would repeat the process and assign to waited and finally raise StopIteration (implicit return None at the end of this async coroutine)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">label, length, *, delay=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Countdown a launch for `length` seconds, waiting `delay` seconds.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is what a user would typically write.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(label, <span class="string">&#x27;waiting&#x27;</span>, delay, <span class="string">&#x27;seconds before starting countdown&#x27;</span>)</span><br><span class="line">    delta = <span class="keyword">await</span> sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(label, <span class="string">&#x27;starting after waiting&#x27;</span>, delta)</span><br><span class="line">    <span class="keyword">while</span> length:</span><br><span class="line">        <span class="built_in">print</span>(label, <span class="string">&#x27;T-minus&#x27;</span>, length)</span><br><span class="line">        waited = <span class="keyword">await</span> sleep(<span class="number">1</span>)</span><br><span class="line">        length -= <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(label, <span class="string">&#x27;lift-off!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>The SleepingLoop is a class with syncronous function that keep calling <code>task.coro.send(now)</code> to resume pause in sleep and in turns countdown.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepingLoop</span>:</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;An event loop focused on delaying execution of coroutines.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Think of this as being like asyncio.BaseEventLoop/curio.Kernel.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *coros</span>):</span><br><span class="line">        self._new = coros</span><br><span class="line">        self._waiting = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_until_complete</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Start all the coroutines.</span></span><br><span class="line">        <span class="keyword">for</span> coro <span class="keyword">in</span> self._new:</span><br><span class="line">            wait_for = coro.send(<span class="literal">None</span>)</span><br><span class="line">            heapq.heappush(self._waiting, Task(wait_for, coro))</span><br><span class="line">        <span class="comment"># Keep running until there is no more work to do.</span></span><br><span class="line">        <span class="keyword">while</span> self._waiting:</span><br><span class="line">            now = datetime.datetime.now()</span><br><span class="line">            <span class="comment"># Get the coroutine with the soonest resumption time.</span></span><br><span class="line">            task = heapq.heappop(self._waiting)</span><br><span class="line">            <span class="keyword">if</span> now &lt; task.waiting_until:</span><br><span class="line">                <span class="comment"># We&#x27;re ahead of schedule; wait until it&#x27;s time to resume.</span></span><br><span class="line">                delta = task.waiting_until - now</span><br><span class="line">                time.sleep(delta.total_seconds())</span><br><span class="line">                now = datetime.datetime.now()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># It&#x27;s time to resume the coroutine.</span></span><br><span class="line">                wait_until = task.coro.send(now)</span><br><span class="line">                heapq.heappush(self._waiting, Task(wait_until, task.coro))</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="comment"># The coroutine is done.</span></span><br><span class="line">                <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>The main function is also syncrounous where we record the start time before we start the run_until_complete withinwhich we enter and exit coroutine <strong>async def countdown</strong> and <strong>def sleep</strong> and time after all tasks are done (heap in the loop being empty) so that we can see the evidence that everything just take around 5 seconds.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Start the event loop, counting down 3 separate launches.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is what a user would typically write.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    loop = SleepingLoop(countdown(<span class="string">&#x27;A&#x27;</span>, <span class="number">5</span>), countdown(<span class="string">&#x27;B&#x27;</span>, <span class="number">3</span>, delay=<span class="number">2</span>),</span><br><span class="line">                        countdown(<span class="string">&#x27;C&#x27;</span>, <span class="number">4</span>, delay=<span class="number">1</span>))</span><br><span class="line">    start = datetime.datetime.now()</span><br><span class="line">    loop.run_until_complete()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Total elapsed time is&#x27;</span>, datetime.datetime.now() - start)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/13/coroutine/" data-id="cl1xqplie0003afno3w24dr53" data-title="Review of How the heck does async/await work in Python 3.5?" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Generator-Coroutines-Python/" rel="tag">Generator, Coroutines, Python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-dp-framework" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/13/dp-framework/" class="article-date">
  <time class="dt-published" datetime="2022-04-13T15:41:08.469Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/13/dp-framework/">Review of dynamic programming framework (fibonnaci, coin change)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://hackmd.io/6MGw9QgbTe-z_5tI3kSwfg"><img src="https://hackmd.io/6MGw9QgbTe-z_5tI3kSwfg/badge" alt="hackmd-github-sync-badge"></a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This is review for dynamic programming framework <a target="_blank" rel="noopener" href="https://labuladong.github.io/algo/1/4/">動態規劃解題套路框架</a></p>
<p>Three elements of DP (dynamic programming):</p>
<ul>
<li>base case: The base case that the answer is known.</li>
<li>subproblems: Child problems such that once they are sovled we can determine unique solution for their parent; subproblems are independent from each others meaning the optimal solution of each subproblem won’t affect its peer. it is often express through state transition equation.</li>
<li>memory table: To reduce duplicate calculation</li>
</ul>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fibonacci-number/">Leetcode 509: Fibonacci number</a></p>
<ul>
<li><p>base case: when n is 0 or 1, we harded the answer to be 0 or 1.</p>
</li>
<li><p>state transition equation: f(n) &#x3D; f(n-1) + f(n-2)</p>
</li>
<li><p>memory table: two elements</p>
</li>
<li><p>space complexity: O(2)</p>
</li>
<li><p>time complexity: O(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp_1 = <span class="number">0</span></span><br><span class="line">        dp_2 = <span class="number">1</span></span><br><span class="line">        dp_new = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp_new = dp_1 + dp_2</span><br><span class="line">            dp_1 = dp_2</span><br><span class="line">            dp_2 = dp_new</span><br><span class="line">        <span class="keyword">return</span> dp_new</span><br></pre></td></tr></table></figure>
</li>
<li><p>Base case: 0 amount requires 0 coin</p>
</li>
<li><p>Subproblem: Assume there are k type of coins, DP(amount, coins) &#x3D; 1 + min(DP(amount-coin[0],coins),DP(amount-coin[1],coins), …, DP(amount-coin[k-1],coins))</p>
</li>
<li><p>memory table: A list with length <code>amount</code>+1 with its elements initialised to amount + 1 so that if the number is not changed it means the subproblem is not solved yet hence we need to calculate the optimal solution for the subproblem and record the result; otherwise retrieve the result</p>
</li>
<li><p>time complexity: O(k*n) because with memory, the number of subproblem is at most n and each subproblem we loop through k coins.</p>
</li>
<li><p>space complexity: O(n)</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/coin-change/">Leetcode 322: Coin change</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.dp = [ amount+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>)]</span><br><span class="line">        self.amount = amount</span><br><span class="line">        self.recursion(coins, amount)</span><br><span class="line">        <span class="keyword">if</span> self.dp[amount] == self.amount+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.dp[amount]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">self,coins,amount</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">            self.dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> amount&lt;<span class="built_in">min</span>(coins):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.dp[amount] !=  self.amount+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.dp[amount]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> coin&gt;amount:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.dp[amount-coin] != self.amount+<span class="number">1</span>:</span><br><span class="line">                sub_problem = self.dp[amount-coin]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sub_problem = self.recursion(coins,amount-coin)</span><br><span class="line">            <span class="keyword">if</span> sub_problem + <span class="number">1</span> &lt; self.dp[amount] <span class="keyword">and</span> sub_problem &gt;= <span class="number">0</span>:</span><br><span class="line">                self.dp[amount] = sub_problem + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.dp[amount] !=  self.amount+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.dp[amount]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dp[amount] = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>     </span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/13/dp-framework/" data-id="cl1xqplig0004afno129628o0" data-title="Review of dynamic programming framework (fibonnaci, coin change)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-programming-python-algorithm/" rel="tag">dynamic programming, python, algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-priority_queue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/13/priority_queue/" class="article-date">
  <time class="dt-published" datetime="2022-04-13T15:41:08.469Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/13/priority_queue/">Simple Python Implementation of Priority Queue via Max heap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://hackmd.io/qDlvP3e5TXSB1Mm2ZMy2OQ"><img src="https://hackmd.io/qDlvP3e5TXSB1Mm2ZMy2OQ/badge" alt="hackmd-github-sync-badge"></a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>While python has heapq to use (which is min heap), e.g.</p>
<p>heapq.heappush(heap, item):Push the value item onto the heap, maintaining the heap invariant.</p>
<p>heapq.heappop(heap):Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0].</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>Just as a practice, I try to write to write a max heap from scratch for integer</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._heap = [<span class="literal">None</span>,]</span><br><span class="line">        self._heap_size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exch</span>(<span class="params">self,A,B</span>):</span><br><span class="line">        temp = self._heap[A]</span><br><span class="line">        self._heap[A] = self._heap[B]</span><br><span class="line">        self._heap[B] = temp</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_swim</span>(<span class="params">self</span>):</span><br><span class="line">        k = self._heap_size</span><br><span class="line">        parent = k // <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> parent&gt;<span class="number">0</span> <span class="keyword">and</span> self._heap[parent]&lt;self._heap[k]:</span><br><span class="line">            self.exch(parent,k)</span><br><span class="line">            k = parent</span><br><span class="line">            parent = k // <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_sink</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            left_child = k*<span class="number">2</span></span><br><span class="line">            right_child = k*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left_child&lt;=self._heap_size:</span><br><span class="line">                bigger = left_child</span><br><span class="line">                <span class="keyword">if</span> k*<span class="number">2</span>+<span class="number">1</span> &lt;= self._heap_size <span class="keyword">and</span> self._heap[left_child]&lt;self._heap[right_child]:</span><br><span class="line">                        bigger = right_child</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> self._heap[k]&lt;self._heap[bigger]:</span><br><span class="line">                    self.exch(k,bigger)</span><br><span class="line">                k = bigger</span><br><span class="line">                left_child = k*<span class="number">2</span></span><br><span class="line">                right_child = k*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,element</span>):</span><br><span class="line">        self._heap.append(element)</span><br><span class="line">        self._heap_size += <span class="number">1</span></span><br><span class="line">        self._swim()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">max</span> = self._heap[<span class="number">1</span>]</span><br><span class="line">        self._heap[<span class="number">1</span>] = self._heap[self._heap_size]</span><br><span class="line">        self._heap[self._heap_size] = <span class="literal">None</span></span><br><span class="line">        self._heap_size -= <span class="number">1</span></span><br><span class="line">        self._sink()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">pq = PriorityQueue()</span><br><span class="line"><span class="keyword">for</span>  i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    n = randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">    pq.push(n)</span><br><span class="line"></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    result.append(pq.pop())</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/13/priority_queue/" data-id="cl1xqplih0005afno1h0wa5u9" data-title="Simple Python Implementation of Priority Queue via Max heap" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python-Algorithm-max-heap/" rel="tag">Python, Algorithm, max-heap</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS-backtrack-python/" rel="tag">DFS, backtrack, python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Generator-Coroutines-Python/" rel="tag">Generator, Coroutines, Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python-Algorithm-max-heap/" rel="tag">Python, Algorithm, max-heap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dynamic-programming-python-algorithm/" rel="tag">dynamic programming, python, algorithm</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/DFS-backtrack-python/" style="font-size: 10px;">DFS, backtrack, python</a> <a href="/tags/Generator-Coroutines-Python/" style="font-size: 10px;">Generator, Coroutines, Python</a> <a href="/tags/Python-Algorithm-max-heap/" style="font-size: 10px;">Python, Algorithm, max-heap</a> <a href="/tags/dynamic-programming-python-algorithm/" style="font-size: 10px;">dynamic programming, python, algorithm</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/13/backtracking/">Review of Back tracking (one kind of DFS) framework</a>
          </li>
        
          <li>
            <a href="/2022/04/13/binarytree/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/04/13/coroutine/">Review of How the heck does async/await work in Python 3.5?</a>
          </li>
        
          <li>
            <a href="/2022/04/13/dp-framework/">Review of dynamic programming framework (fibonnaci, coin change)</a>
          </li>
        
          <li>
            <a href="/2022/04/13/priority_queue/">Simple Python Implementation of Priority Queue via Max heap</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Ho Ngok Chao<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>